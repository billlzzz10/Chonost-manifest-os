#!/usr/bin/env python3
"""
Auto Vault Watcher - ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
"""

import os
import time
import json
import shutil
import logging
from pathlib import Path
from typing import Dict, List, Any, Optional, Set
from datetime import datetime
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileCreatedEvent, FileModifiedEvent, FileMovedEvent
import threading
import queue

class VaultFileHandler(FileSystemEventHandler):
    """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡πÅ‡∏õ‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå"""
    
    def __init__(self, vault_manager: 'AutoVaultWatcher'):
        self.vault_manager = vault_manager
        self.pending_files: Set[str] = set()
        self.processing_queue = queue.Queue()
        self.processing_thread = None
        self.start_processing_thread()
    
    def start_processing_thread(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏° thread ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå"""
        self.processing_thread = threading.Thread(target=self._process_files_worker, daemon=True)
        self.processing_thread.start()
    
    def _process_files_worker(self):
        """Worker thread ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå"""
        while True:
            try:
                file_path = self.processing_queue.get(timeout=1)
                if file_path is None:  # Signal to stop
                    break
                
                self.vault_manager.process_file(file_path)
                self.processing_queue.task_done()
                
            except queue.Empty:
                continue
            except Exception as e:
                logging.error(f"Error processing file {file_path}: {e}")
    
    def on_created(self, event):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà"""
        if not event.is_directory and self._is_target_file(event.src_path):
            self._handle_file_event(event.src_path, "created")
    
    def on_modified(self, event):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡πÑ‡∏ü‡∏•‡πå"""
        if not event.is_directory and self._is_target_file(event.src_path):
            self._handle_file_event(event.src_path, "modified")
    
    def on_moved(self, event):
        """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå"""
        if not event.is_directory and self._is_target_file(event.dest_path):
            self._handle_file_event(event.dest_path, "moved")
    
    def _is_target_file(self, file_path: str) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        path = Path(file_path)
        return path.suffix.lower() in ['.txt', '.md', '.json']
    
    def _handle_file_event(self, file_path: str, event_type: str):
        """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå‡πÑ‡∏ü‡∏•‡πå"""
        try:
            # ‡∏£‡∏≠‡∏™‡∏±‡∏Å‡∏Ñ‡∏£‡∏π‡πà‡πÉ‡∏´‡πâ‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏™‡∏£‡πá‡∏à‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ô
            time.sleep(0.5)
            
            if os.path.exists(file_path):
                # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏•‡∏á‡∏Ñ‡∏¥‡∏ß‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•
                self.processing_queue.put(file_path)
                logging.info(f"Queued file for processing: {file_path} ({event_type})")
                
        except Exception as e:
            logging.error(f"Error handling file event {file_path}: {e}")

class AutoVaultWatcher:
    """‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á‡πÅ‡∏•‡∏∞‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö Vault ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥"""
    
    def __init__(self, vault_path: str):
        self.vault_path = Path(vault_path)
        self.observer = Observer()
        self.file_handler = VaultFileHandler(self)
        self.running = False
        
        # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ logging
        self._setup_logging()
        
        # ‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤
        self.config = self._load_config()
        
        # ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô
        self.stats = {
            'files_processed': 0,
            'files_moved': 0,
            'files_organized': 0,
            'errors': 0,
            'start_time': datetime.now().isoformat()
        }
    
    def _setup_logging(self):
        """‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ logging"""
        log_dir = self.vault_path / "logs"
        log_dir.mkdir(exist_ok=True)
        
        log_file = log_dir / f"vault_watcher_{datetime.now().strftime('%Y%m%d')}.log"
        
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file, encoding='utf-8'),
                logging.StreamHandler()
            ]
        )
    
    def _load_config(self) -> Dict[str, Any]:
        """‡πÇ‡∏´‡∏•‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤"""
        config_file = self.vault_path / "vault_watcher_config.json"
        
        default_config = {
            'watch_extensions': ['.txt', '.md', '.json'],
            'auto_organize': True,
            'move_duplicates': True,
            'create_readme': True,
            'organize_rules': {
                'prompts': ['prompt', 'copilot', 'template'],
                'templates': ['template', 'form', 'format'],
                'tools': ['tool', 'utility', 'script'],
                'notes': ['note', 'memo', 'idea'],
                'data': ['data', 'database', 'config']
            },
            'target_folders': {
                'prompts': '08_Templates-Tools/Prompts/General',
                'templates': '08_Templates-Tools/Document_Templates',
                'tools': '08_Templates-Tools/Tools_and_Utilities',
                'notes': '06_NOTE',
                'data': '08_Templates-Tools/Databases'
            },
            'exclude_patterns': ['temp', 'tmp', 'backup', 'old'],
            'min_file_size': 10  # bytes
        }
        
        if config_file.exists():
            try:
                with open(config_file, 'r', encoding='utf-8') as f:
                    user_config = json.load(f)
                    default_config.update(user_config)
            except Exception as e:
                logging.error(f"Error loading config: {e}")
        
        return default_config
    
    def start_watching(self):
        """‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á"""
        try:
            logging.info("üöÄ ‡πÄ‡∏£‡∏¥‡πà‡∏° Auto Vault Watcher...")
            logging.info(f"üìÅ ‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á: {self.vault_path}")
            logging.info(f"üìã ‡∏Å‡∏≤‡∏£‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤: {json.dumps(self.config, ensure_ascii=False, indent=2)}")
            
            # ‡πÄ‡∏£‡∏¥‡πà‡∏° observer
            self.observer.schedule(self.file_handler, str(self.vault_path), recursive=True)
            self.observer.start()
            
            self.running = True
            logging.info("‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢")
            
            # ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
            self._show_status()
            
        except Exception as e:
            logging.error(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á: {e}")
            raise
    
    def stop_watching(self):
        """‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á"""
        try:
            logging.info("üõë ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á...")
            
            self.running = False
            
            # ‡∏´‡∏¢‡∏∏‡∏î observer
            self.observer.stop()
            self.observer.join()
            
            # ‡∏™‡πà‡∏á‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏´‡∏¢‡∏∏‡∏î worker thread
            self.file_handler.processing_queue.put(None)
            if self.file_handler.processing_thread:
                self.file_handler.processing_thread.join(timeout=5)
            
            # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥
            self._save_stats()
            
            logging.info("‚úÖ ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢")
            
        except Exception as e:
            logging.error(f"‚ùå ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á: {e}")
    
    def process_file(self, file_path: str):
        """‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå"""
        try:
            path = Path(file_path)
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if not self._should_process_file(path):
                return
            
            logging.info(f"üîç ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå: {path.name}")
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÑ‡∏ü‡∏•‡πå
            if path.stat().st_size < self.config['min_file_size']:
                logging.info(f"‚è≠Ô∏è ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏•‡πá‡∏Å‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ: {path.name}")
                return
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            if self._is_in_correct_location(path):
                logging.info(f"‚úÖ ‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á: {path.name}")
                return
            
            # ‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡πÑ‡∏ü‡∏•‡πå
            if self.config['auto_organize']:
                self._organize_file(path)
            
            self.stats['files_processed'] += 1
            
        except Exception as e:
            logging.error(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏• {file_path}: {e}")
            self.stats['errors'] += 1
    
    def _should_process_file(self, file_path: Path) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏Ñ‡∏ß‡∏£‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ô‡∏≤‡∏°‡∏™‡∏Å‡∏∏‡∏•‡πÑ‡∏ü‡∏•‡πå
        if file_path.suffix.lower() not in self.config['watch_extensions']:
            return False
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡∏¢‡∏Å‡πÄ‡∏ß‡πâ‡∏ô
        for pattern in self.config['exclude_patterns']:
            if pattern.lower() in file_path.name.lower():
                return False
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏∞‡∏ö‡∏ö
        if file_path.name.startswith('.'):
            return False
        
        return True
    
    def _is_in_correct_location(self, file_path: Path) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà"""
        try:
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏´‡∏•‡∏±‡∏Å‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            main_folders = [
                '00_DASHBOARD', '01_MANUSCRIPT', '02_CHARACTERS',
                '03_WORLDBUILDING', '04_PLOT-TIMELINE', '05_SYSTEMS-LORE', '06_NOTE',
                '08_Templates-Tools'
            ]
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏¢‡πà‡∏≠‡∏¢‡∏Ç‡∏≠‡∏á Templates-Tools ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
            templates_subfolders = [
                'Prompts/General', 'Prompts/Default_Prompts', 'Prompts/Smart_Connections',
                'Document_Templates', 'Tools_and_Utilities', 'Databases'
            ]
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏´‡∏•‡∏±‡∏Å
            for folder in main_folders:
                if folder in str(file_path):
                    return True
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏¢‡πà‡∏≠‡∏¢‡∏Ç‡∏≠‡∏á Templates-Tools
            for subfolder in templates_subfolders:
                if f'08_Templates-Tools/{subfolder}' in str(file_path):
                    return True
            
            return False
            
        except Exception as e:
            logging.error(f"Error checking file location: {e}")
            return False
    
    def _organize_file(self, file_path: Path):
        """‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡πÑ‡∏ü‡∏•‡πå"""
        try:
            # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
            target_folder = self._determine_target_folder(file_path)
            
            if not target_folder:
                logging.info(f"‚è≠Ô∏è ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á: {file_path.name}")
                return
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á
            target_path = self.vault_path / target_folder
            target_path.mkdir(parents=True, exist_ok=True)
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏ü‡∏•‡πå‡∏ã‡πâ‡∏≥
            target_file = target_path / file_path.name
            if target_file.exists():
                if self.config['move_duplicates']:
                    # ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå
                    new_name = self._generate_unique_name(target_file)
                    target_file = target_path / new_name
                    logging.info(f"üîÑ ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏ã‡πâ‡∏≥: {file_path.name} -> {new_name}")
                else:
                    logging.info(f"‚è≠Ô∏è ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏ü‡∏•‡πå‡∏ã‡πâ‡∏≥: {file_path.name}")
                    return
            
            # ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå
            shutil.move(str(file_path), str(target_file))
            
            logging.info(f"‚úÖ ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå: {file_path.name} -> {target_folder}")
            
            self.stats['files_moved'] += 1
            self.stats['files_organized'] += 1
            
            # ‡∏™‡∏£‡πâ‡∏≤‡∏á README ‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô
            if self.config['create_readme']:
                self._ensure_readme_exists(target_path)
            
        except Exception as e:
            logging.error(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö {file_path}: {e}")
            self.stats['errors'] += 1
    
    def _determine_target_folder(self, file_path: Path) -> Optional[str]:
        """‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏õ‡∏•‡∏≤‡∏¢‡∏ó‡∏≤‡∏á"""
        try:
            file_name = file_path.name.lower()
            file_content = ""
            
            # ‡∏≠‡πà‡∏≤‡∏ô‡πÄ‡∏ô‡∏∑‡πâ‡∏≠‡∏´‡∏≤‡πÑ‡∏ü‡∏•‡πå‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    file_content = f.read(1000).lower()  # ‡∏≠‡πà‡∏≤‡∏ô 1000 ‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡πÅ‡∏£‡∏Å
            except:
                pass
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ï‡∏≤‡∏°‡∏Å‡∏é‡∏Å‡∏≤‡∏£‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö
            for category, keywords in self.config['organize_rules'].items():
                for keyword in keywords:
                    if keyword in file_name or keyword in file_content:
                        return self.config['target_folders'][category]
            
            # ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏Å‡∏é‡πÉ‡∏î‡πÜ ‡πÉ‡∏´‡πâ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏õ Notes
            return self.config['target_folders']['notes']
            
        except Exception as e:
            logging.error(f"Error determining target folder: {e}")
            return None
    
    def _generate_unique_name(self, file_path: Path) -> str:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ä‡∏∑‡πà‡∏≠‡πÑ‡∏ü‡∏•‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡∏ã‡πâ‡∏≥"""
        counter = 1
        name = file_path.stem
        suffix = file_path.suffix
        
        while file_path.exists():
            new_name = f"{name}_{counter}{suffix}"
            file_path = file_path.parent / new_name
            counter += 1
        
        return file_path.name
    
    def _ensure_readme_exists(self, folder_path: Path):
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á README ‡∏ñ‡πâ‡∏≤‡∏à‡∏≥‡πÄ‡∏õ‡πá‡∏ô"""
        readme_path = folder_path / "README.md"
        
        if not readme_path.exists():
            try:
                folder_name = folder_path.name
                date = datetime.now().strftime("%Y-%m-%d")
                
                content = f"""# üìÅ {folder_name.replace('_', ' ')}

## üéØ ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå
‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö {folder_name.replace('_', ' ').lower()}

## üìã ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞
- [x] ‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô

## üìÅ ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏ô‡πÇ‡∏ü‡∏•‡πÄ‡∏î‡∏≠‡∏£‡πå
{self._generate_file_list(folder_path)}

---
*‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î: {date}*
"""
                
                with open(readme_path, 'w', encoding='utf-8') as f:
                    f.write(content)
                
                logging.info(f"üìù ‡∏™‡∏£‡πâ‡∏≤‡∏á README: {folder_path.name}")
                
            except Exception as e:
                logging.error(f"Error creating README: {e}")
    
    def _generate_file_list(self, folder_path: Path) -> str:
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö README"""
        try:
            files = [f for f in folder_path.iterdir() if f.is_file() and f.name != 'README.md']
            if not files:
                return "- ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÑ‡∏ü‡∏•‡πå"
            
            file_list = []
            for file in sorted(files):
                file_list.append(f"- {file.name}")
            
            return '\n'.join(file_list)
            
        except Exception as e:
            logging.error(f"Error generating file list: {e}")
            return "- ‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡πÑ‡∏ü‡∏•‡πå"
    
    def _show_status(self):
        """‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô"""
        print("\n" + "="*80)
        print("üéØ Auto Vault Watcher - ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
        print("="*80)
        print(f"üìÅ Vault Path: {self.vault_path}")
        print(f"üîç ‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå: {', '.join(self.config['watch_extensions'])}")
        print(f"ü§ñ ‡∏à‡∏±‡∏î‡∏£‡∏∞‡πÄ‡∏ö‡∏µ‡∏¢‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥: {'‚úÖ' if self.config['auto_organize'] else '‚ùå'}")
        print(f"üìù ‡∏™‡∏£‡πâ‡∏≤‡∏á README: {'‚úÖ' if self.config['create_readme'] else '‚ùå'}")
        print(f"üîÑ ‡∏¢‡πâ‡∏≤‡∏¢‡πÑ‡∏ü‡∏•‡πå‡∏ã‡πâ‡∏≥: {'‚úÖ' if self.config['move_duplicates'] else '‚ùå'}")
        print("\nüí° ‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥:")
        print("   - ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÄ‡∏á‡∏µ‡∏¢‡∏ö‡πÜ ‡πÉ‡∏ô‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏•‡∏±‡∏á")
        print("   - ‡∏à‡∏±‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏ã‡∏ü")
        print("   - ‡∏Å‡∏î Ctrl+C ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î")
        print("="*80)
    
    def _save_stats(self):
        """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ó‡∏≥‡∏á‡∏≤‡∏ô"""
        try:
            stats_file = self.vault_path / "vault_watcher_stats.json"
            
            stats_data = {
                'stats': self.stats,
                'config': self.config,
                'last_run': datetime.now().isoformat()
            }
            
            with open(stats_file, 'w', encoding='utf-8') as f:
                json.dump(stats_data, f, ensure_ascii=False, indent=2)
            
            logging.info(f"üìä ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥: {stats_file}")
            
        except Exception as e:
            logging.error(f"Error saving stats: {e}")

def main():
    """‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å"""
    vault_path = r"F:\01_WRI\Obsidian\Vault"
    
    try:
        # ‡∏™‡∏£‡πâ‡∏≤‡∏á watcher
        watcher = AutoVaultWatcher(vault_path)
        
        # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á
        watcher.start_watching()
        
        # ‡∏£‡∏±‡∏ô‡πÑ‡∏õ‡πÄ‡∏£‡∏∑‡πà‡∏≠‡∏¢‡πÜ ‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏Å‡∏î Ctrl+C
        try:
            while watcher.running:
                time.sleep(1)
        except KeyboardInterrupt:
            print("\nüõë ‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡∏´‡∏¢‡∏∏‡∏î...")
        
        # ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ù‡πâ‡∏≤‡∏°‡∏≠‡∏á
        watcher.stop_watching()
        
    except Exception as e:
        print(f"‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {e}")
        return 1
    
    return 0

if __name__ == "__main__":
    exit(main())
